Node.js Essential Training
==========================
Alex Banks on lynda.com
==========================
What is Node.js
---------------
Nodejs is not a programming language or framework. It is a runtime environment for Javasript files. Node.js allows us to create javascript applications that run outside the scope of the browser. That is, the JS files were historically run within a browser using a JavaScript Engine. For example, SpiderMonkey and Rhino for Firefox, V8 for Chrome, Nitro for Safari. However, in 2009, Ryan Dahl created a copy of the V8 engine as Node.exe which could run the .js files outside without the need of a browser. In 2011, Node Package Manager (NPM) was created, which allowed sharing of open source libraries.

How nodejs works
----------------
Nodejs works in asynchronously, non-blocking, event driven i/o. This means that every request that we do to the server is processed through a single thread.

Nodejs command prompt
---------------------
node -v
	[displays the version of nodejs]
node <fileName>
	[runs a nodejs file] 

Global Objects
--------------
In regular javascript, the window/document is the global object. All the global variables and methods are attached to it. However, in Nodejs every file that we create is considered as a module. Any global variable that we create are added to the module, not the global namespace. So, we cant to access a global variable that we created like this: console.log(global.variableName); however, we can still access the variable like this: console.log(variableName). 

Additionally, anything that is available in Javascript is available to the environment in nodejs. As nodejs 4 and above supports ES6, we can also use template strings like this: console.log(`My name is ${myName}`);

We can import other nodejs modules using "require" function, like this: var path = require("path"). This imports the path module that comes with the nodejs. To console.log the file name from the path, we can write: 
	var path = require("path");
	console.log(path.basename(__filename)); 

Reference to the current directory: console.log(__dirname);
Reference to the current module: console.log(__filename);

console object:
	console.log("Hello, world!");
console object is part of the global namespace, which is default; so, we can also write: 
	global.console.log("Hello, World!");

Process Object
--------------
One important object that is available to us globally is the process object. It can be accessed from anywhere, and it contains functionality that allows us to interact with information about the current process instance. We can use the process object to get environment information, read environment variables, communicate with the terminal, or parent processes, through standard input and standard output. We can even exit the current process. This object essentially gives us a way to work with the current process instance. All of this information will be saved in a variable called 'process.argv', which stands for the argument variables used to start the process.
If we console.log(process.argv) through a file, we get an array which contains a path to nodejs and the .js file that is run. If we pass additional arguments to it, it will also display those. For example, if we pass the following arguments while running the file:
'node app.js --user George --greeting "Good Day, Sir!"', we would get the following output:
	[ 'C:\\Program Files\\nodejs\\node.exe',
  'D:\\School of Learning\\Node.js\\Ex_Files_Nodejs_EssT\\Ex_Files_Nodejs_EssT\\Exercise Files\\Ch03\\03_02\\start\\app',  '--user',  'George',
  '--greeting',
  'Good day, Sir!' ] 
So, the process.argv parameter actually stores all the arguments that are passed to the app. It always holds in the first position the absolute pathname of the executable that started a nodejs process and in the second position the actual javascript file that is being executed.

Another feature of the process object is the standard input and standard output. This can used to communicate with the process and terminals. Using the process object, we can write to the standard output, which the console.log uses by default. We can write to the default output device like following:
	process.stdout.write("Hello");
To listen to the standard input, we add an event listener with 'data' event. The 'data' event means when the user types some data and hits enter, like this:
	process.stdin.on('data', function(){
		process.stdout.write('\n' +data.toString().trim() +'\n');
	});
To exit from the program, we can write:
	process.exit();
To listen to the exit prompt we can write: 
	process.on('exit', function(){
		//actions
	});

Global Timing Functions
-----------------------
There are some global timing functions with which we can control the timing. The first one is the setTimeout() method. This method takes two parameters. The first one being the function which it should run after the stipulated time is over, and the second parameter is how many miliseconds to wait before running the aforementioned function. So, it may look like this:
	setTimeout(function(){
		console.log("done");
	}, 3000);
Another timing method is setInterval() which runs a function after a fixed interval time. This method also takes two parameters. The first method is the function that it will run after each of the fixed interval and the second parameter is the amount of time in miliseconds its going to wait before running the program. This may look like:
	setInterval(function(){
		console.log("0.5 second passed");
	}, 500);
However, this setInterval function will run forever! We might want to stop this function from running after certain time. To do that we need to use the assignment method of function declaration for the setInterval function and then can combine another method, clearInterval(), along with the two that we have just learned. The clearInterval methods takes a setInterval function as its parameter. This will look something like this:
	var timer = setInterval(function(){
	  console.log("0.5 seconds passed");
	}, 500)

	setTimeout(function(){
	  clearInterval(timer);
	  console.log("Done");
	},5000);

Core Node Modules
-----------------
There are several code modules that come with nodejs. For example, we used the 'path' module to extract the path of the current folder and file. We can also use path.join() method to create a path like this: 
	path.join(__dirname, "www");
This will create a path that has the current directory name, followed by a subdirectory name "www".

Another core module is the 'util' module. There is a util.log() method in this. This is similar to the console.log() global module. However, the 'util.log()' method also inserts the timestamp to the console.

Another core module is 'v8' module. This can be used to get information regarding memory. A very important method is the v8.getHeapStatistics() method, which returns total memory size, total physical size, total available, used memory, and heap size limit.

The 'readline' module allows us to ask questions to our terminal user. This is built around the standard input and output objects that control prompting user with questions and saving those answers. After importing the module (var readline = require('readline'), we need to instantiate the class to an object and run the object:
	//here rl is the instance of class readline that has a method createInterface, which takes two parameters, one for the input and the other one for the standard output
	var rl = readline.createInterface(process.stdin, process.stdout);
	//this is to create a smooth process of asking questions and getting an answer for that. To achieve this we need to invoke the question() method of rl object and pass to parameters to it. The first parameter is the question that we want to ask and the second one is the callback function that will be invoke once we have an answer.
	rl.question("What is your name", function(answer){
		console.log(answer);
	});
We can also set up a prompt to ask a question over and over. We can do this by using the method rl.setPrompt('question?');
Then we can invoke the prompt method like this: rl.prompt(). Then to listen to any answer we need to listen to a 'line' that is when the user enter a line some callback function will be invoked like this:
	rl.on('line', function(answer){
		console.log(answer.trim());
	});
To exit out of a readline instance we can use rl.close() method.
We can also use another event listener that will invoke a callback function before closing the rl object. We listen to the 'close' event like this:
	rl.on('close', function(){
		console.log (realPerson.name);
	});

Event Emitter
-------------
This is a module to listen to different events. In fact, we have have been using an instance of the eventEmitter with .on() method. The eventEmitter is a part of the 'event' module. We import that event like this:
	var events = require('events');
The event emitter is a constructor; so, we need to create an instance of the object like this:
	var emitter = new events.EventEmitter();
We can also create an object directly from the constructor by invoking the constructor from the 'require' method, like this:
	var EventEmitter = require('events').EventEmitter;

An important feature of this object is that we can create our own customeEvent and invoke a callback function if that event occurs. Like this:
	emitter.on('customEvent', function(message, status){
		console.log("Status: " +status);
		console.log("Message: " +message);
	});
However, as this is a 'customEvent', we also need to trigger/emit this event; otherwise, the previous callback function will never be invoked. So, emit the event we use 'emit()' method like this:
	emitter.emit('customEvent', "Hello World", 200);
We can increase the power of eventEmitter by combining the event object with other objects. To do this we can allow other objects inherit the EventEmitter. To inherit a class to another class, we 'require' the 'util' module (var util = require('util')). Then we inherit the properties of one object to other object by invoking the 'inherits()' method from the 'util' module, like this:
	util.inherits(Person, EventEmitter);
This means that we have made an object called 'Person', which inherits all the properties of 'EventEmitter' object. Then we can make the object listen to a custom event and also trigger an custom event from the other object. A detailed example of this process is: 
	//imports the EventEmitter constructor from 'events' module
	var EventEmitter = require('events').EventEmitter;
	//imports the util module
	var util = require('util');
	//defines a Person object constructor
	var Person = function(name){
	  this.name = name;
	};
	//Person inherits the EventEmitter object
	util.inherits(Person, EventEmitter);
	//create a new instance of Perons called ben
	var ben = new Person ("Ben Franklin");
	//invokes a callback function triggered by custom
	//event called 'speak'
	ben.on('speak', function(said){
	  console.log(`${this.name} said ${said}`);
	});
	//emits the 'speak' event
	ben.emit('speak', "Whatever you is correct");

Exporting Custom Modules
------------------------
We can create our own custom modules that can be used again to stop repeating the same code. The modules also have .js extensions. By definitions all the properties and methods of a module are private; so, we can't use them in other modules. If we want to reuse them, we need to export it from the module that we want to use. To do this we need to use the module.exports property, which contains the object returned by the 'require' method. So, whatever we put in to this module.export property will be returned when require this module. For example: if we create a Person.js module that constains a object constructor function called 'Person' and then write the following line:
	module.exports = Person;
This puts the Person constructor in the module.exports property. So, whenever we 'require' this Person module, we will be returned this Person constructor. When reusing this module, we need to specify the path to the module in relative format and the name of the module is by default assumed to be .js format. So we can write:
	var Person = require(./lib/Person);

Child process Module
--------------------
Node.js comes with a Child Process module which allows you to execute external processes in your environment. In other words, your Node.js app can run and communicate with other applications on the computer that it is hosting. To do so, we 'require' the 'child_process' module:
	var exec = require('child_process');
Then to execute a command, we can invoke the 'exec' method from the module. This has two parameters; the first one is the command itself as a string and the second one is a callback function which gets any error of the command and the output of the first paramenter as arguments. Like this:
	exec("dir", function(err, stdout){
		if(err){
			throw err;
		}
		console.log("Listing Finished");
		console.log(stdout);
	});

Another useful method is the 'spawn' method, which is useful for processes that take some time to process and finish or is ongoing.

File System Module
------------------
We can work with the filesystem through nodejs. Just to note that all the methods in the filesystem module have a synchronous version and an asynchronous version. The module that we would 'require' for these operations is 'fs', like this:
	var fs = require('fs');
Once we have imported the module, we can read the list everything in a directory using the following synchronous method:
	var files = fs.readdirSync('./lib');
However, this will block the process, as this is synchronous method, from processing anything else until it is done. So, we can use asynchronous method. However, asynchronous functions work differently. It will not return the output like the synchronous method; so, we can't assign that to a variable any longer. Rather, it will run a command and keep listening to whether that finish. When that task finishes it will run a callback function. So, the structure of this method is like this:
	fs.readdir('./lib', function(err, files){
		if(err){
			throw err;
		}
		console.log(files);
	});

We can also read the contents of text and binary files. If we are reading from a text file, we need to send the module the encoding system (like utf-8), otherwise it will automatically read the file as binary file. To read a file synchronously, we can use the 'readFileSync' method like this:
	var contents = fs.readFileSync("./lib/sayings.md", "UTF-8");
To read the files asynchronously, like this:
	fs.readFile("./lib/sayings.md","UTF-8", function(err, content){
		if(err){
			throw err;
		}
		console.log(content);
	});
We can combine the readdir and readfile methods. However, to use these two together, we would need the 'path' module, like this:
	var fs = require('fs');
	var path = require('path');
	fs.readdir('./lib', function(err, files){
	  files.forEach(function(fileName){
	    var file = path.join(__dirname, "lib", fileName);
	    var stats = fs.statSync(file);
	    if(stats.isFile() && fileName !== ".DS_Store"){
	      fs.readFile(file,"UTF-8", function(err, contents){
	        console.log(contents);
	      });
	    }
	  });
	});
We can also create and wrie to files using this module. The asynchronous method used to achieve that is the 'writeFile' method. This method takes three arguments; the first one is the name of the file, the second one is the content that we want to write, and the third argument is the callback function that will run once this process is done. The syntax may look like:
	fs.writeFile('sample.md', md.trim(), function(err){
	  console.log("File Created");
	});
We can also append some text to a file. The method used for this is 'appendFile', which takes three parameters; the first one is the name of the file, the second one is the content, and the third is the callback function. In the synchronous method, only name of file and text to append is provided as arguments. For example:
	fs.appendFileSync(realPerson.name +".md", `* ${saying.trim()}\n`);
We can also work with directories in 'fs' module. The method to create directories is 'mkdir'. For asynchronous 'mkdir' method we need to pass two parameters; the first one is the name of the directory, and the second one is the callback function, which sould inturn have an errro parameter. 
	fs.mkdir("lib", function(err){
	    if(err){
	      console.log(err);
	    } else{
	      console.log("Directory Created");
	    }
  	});
We can also check whether a directory exits. We use the exitsSync method, which returns a boolean value. We can write this like:
	fs.existsSync("lib");

We can rename and move files and folder. We use he rename() method for this purpose like this:
	fs.rename("./lib/notes.md","./notes.md", function(err){
		if(err){
			console.log(err);
		} else{
			console.log("File moved");
		}
	});

We can also delete files using unlink() method like this:
	fs.unlink("./lib/notes.md", function(err){
		err ? console.log(err) : console.log("File Deleted"); 
	});
To remove non-remove directories, we use the "rmdir()" method like this:
	fs.rmdir("./lib/assests", function(err){
		if(err){
			throw err;
		}
		console.log("Directory Removed");
	});

We can implement readable file streams that can read files in small chunks. This technique is very useful for reading large files. To use this, first we need to create a read stream like:
	var stream = fs.createReadStream("./chat.log","UTF-8");
Then we can start listening to an 'data' event and invoke a callback function, which receives a chunk read from the file. For example:
	stream.on('data', function(chunk){
		process.stdout.write("Size of the chunk: +chunk.length\n");
	});
We can also implement a instance of write stream to write small chunks of data in a file. 
	var stream = fs.createWriteStream("./chat.log");
To actually write data to the file we can use 'write()' method like this:
	stream.write("What would you say");
To close a write stream we use the following method:
	stream.close();

HTTP and HTTPS Module
---------------------
The HTTP module will be used for creating web servers, for making requests, for handling responses. There are two modules for this. Nodejs supports both http and https module. To import the https or http module, we need to require the respective module:
	var https = require('https');
We can work with a https request with request() method. The request method takes two parameters, in general. The first parameter contains the options of the request in javascript object and the second parameter is a callback function. First we need to create the options object, which may look like this:
	var options = {
	  hostname: "en.wikipedia.org",
	  port: 443,
	  path: "/wiki/George_Washington",
	  method: "GET",
	};
Then we invoke the request() method. The data will be downloaded in chunks. While the data is downloading, we can add that to a variable to preserve it and when it finishes downloading, we can use the 'writeFile' method of 'fs' module to create a file from the data downloaded. This can be done in the follwoing way:
	//invoking the request method and passing it the options
	var req = https.request(options, function(res){
		res.on('data', function(chunk){
			responseBody += chunk;
		});
		res.on('end',function(){
			fs.writeFile("George-Washington.html", responseBody, function(err){
				if(err){
					throw err;
				}
				console.log("File downloaded and written");
			});
		});
	});

Additionally, we can use some properties like:
	'res.statusCode' to get the status code
	'res.headers' to get the header data

We can build web servers using nodejs, using http and https modules. However, if we want to create a https server, we would need a security certificate. To create a web server, we would use the createServer() method, which can be assigned to a variable and invokes a callback method. The parameters of the callback function are 'request' sent to the server and the 'response' that the server is sending back to the client. This might look like this:
	var server = http.createServer(function(request,response){
		response.writeHead(200,"Content-type":"text/plain");
		response.end("Hello, World!");
	});
	server.listen(3000);
	console.log("Server Listening to port 3000");
This creates the response as "text/plain" as in this case we are sending back plain text. If we would sent back 'html' file, then the response would be "text/html". Also, after creating the server we are listening to port 3000 for any incoming connections. The last line of code is just for us to make sure that the server is running.

In this case, we are just serving normal text. However, we can also serve file. To do that we need to use our http module along with our 'fs' module. Like before we use 'createServer' method to to create the server. Then we use the 'fs' module to invoke 'readFile' method for the html file that we have in our server. We write the code for that like this:
	if(req.url === '/'){
		fs.readFile("./public/index.html","UTF-8", function(err, html){
			res.writeHead(200, {"Content-type": "text/html"});
			res.end(html);
		});
	}
Additionally, we can responde to an error message if the client didn't request for the home page. This will work as a error handling method:
	else{
		res.writeHead(404, {"Content-type":"text/plain"});
		res.end("404 File not found");
	}
However, these will only work for home page and all other pages/files requested will get an error message. So, if the website requests for a particular file as css file, we can use 'path', 'fs', and 'http' modules together. First, we can create a regular expression conditional to see if the requested url matches a particular file type. Then we need to create a path to the file requested by the join() method, then we need to create an instance of readStream with that file path and, only if the file is text, the type of encoding. Then we would use the writeHead method of http module with 'content-type' being the type of file, for css: text/css, for jpg: image/jpeg. Then we 'pipe' the stream that we created earlier to the response variable.
	if(req.url.match(/.css$/)){
		var cssPath = path.join(__dirname, "public", req.url);
		var fileStream = fs.createReadStream(cssPath, "UTF-8");
		res.writeHead(200, {"Content-type":"text/css"});
		fileStream.pipe(res);
	}
Through 'http' module, we can also send JSON data like an API. For that we would need the JSON file ready in the file system, which we will be able to send to client, once they request for it. First we need to import http module and the JSON file. To this we as previously done, use createServer() method with a callback fucntion that has two parameters: request and response. Then inside the callback we invoke the writeHead() method on the response and pass success code of 200 and "content-type" of "text/json". Also at the end of the response  we pass the stringify format of the data from the JSON. 
	ar http = require("http");
	var data = require("./data/inventory");
	http.createServer(function(req,res){
	  res.writeHead(200, {"Content-type":"text/json"});
	  res.end(JSON.stringify(data));
	}).listen(3000);
This however return the complete JSON data; if we want the data to be filtered on a specific parameter, we can check for the that in the url with an conditional statement. If the conditions are met, it will invoke a function and pass that function the response. Then we create a variable, which will an array containing all the objects that match particular condition. To do this, we invoke the filter() method on the JSON data, which will in turn invoke a callback function. The callback will return a boolean value by checking for the condition. The whole thing may look something like this:
	if(req.url === "/instock"){
    	listInStock(res);
	}
	function listInStock(res){
	  var inStock = data.filter(function(item){
	    return item.avail === "In stock";
	  });
	  res.end(JSON.stringify(inStock));
	}

Till this far we have been working with only 'GET' method of HTTP. However, there are other methods that can be done through http. One of those is the 'POST' method. This methods means posting something to the http connection, usually done through 'forms' in html. In the html, the 'form' element takes two attributes, action and method. This method would have a value of 'post', which means when the user clicks 'submit' in the webpage this form sends the information of the form to the web server through http connection. We can check in our javascript file whether the request method is "POST"; if it is, then we can create a variable with empty body and listen to 'data' event on request, which will invoke a callback function. The callback will have a parameter of "chunk" and within the function we will concatenate the chunk with the empty body variable. Once the reading is done, we can also listen to 'end' event which will invoke another callback function, then writeHead() on response and may send back a html with the information just received through "POST". For example:
	if(req.method === "POST"){
	    var body = "";
	    req.on('data', function(chunk){
	      body += chunk;
	    });
	    req.on('end', function(){
	      res.writeHead(200, {"Content-Type": "text/html"});
	      res.end(`
	        <DOCTYPE html>
	        <html>
	          <head>
	            <title>Form Results</title>
	          </head>
	          <body>
	            <h2>Your Form Result</h2>
	            <p>${body}</p>
	          </body>
	        </html>
	      `);
	    });
	  }

NPM Packages
------------
Till this far we have been working with node.js core modules. However, the reason nodejs is so powerfult is for the open-source community and libraries. We can look for these modules and install those from the command prompt. We can install the packages locally(for a specific project) or globally (for the computer). To install locally, we need to go to that directory and type in the following command:
	npm install <packageName>
To install a package globally, we need to type in the following command:
	npm install -g <packageName>
On MAC/Linux we may have to include 'sudo' command got give it permission to install in system directories. To check for all the packages installed in a directory, we can type:
	npm ls
To uninstall a package we can type:
	npm remove <packageName>

Package.json
------------
All NPM (Node Package Manager) packages contain a file, usually in the project root, called package.json file. package.json contains all the information of your web app.It contains all the metadata{set of data which describes and gives info about all other data}. It is the first file your browser looks for, to find all the information of your web app. This includes 'dependencies' that is other modules that this module uses. package.json provides a simple way to keep track of packages that are being used in application. We can create the package.json file using the following command:
	npm init
This command will guide us through the creation of the json file. Once created we can install dependencies and include that automatically in the json file with the following command:
	npm install <dependencyName> --save
However, if we choose to share our app, we don't want to share it along with the dependencies. Because that will make it large. So, at this point, we can go ahead and delete all the dependencies MANUALLY from the explorer. However, as the names required to run the app will stil be in the json file, when we want to install the dependencies necessary to run it, we can just go to the console and type the following command to install all the dependencies in a single shot:
	npm install
If we want to remove a package and update that in our json file, we can type:
	npm remove <packageName> --save

Expess Module
-------------
After we install our dependencies in the folder we are working on, we can 'require' them in the app. In this case, after installing the express module, we can require it in the following way: 
	var express = require("express");

Then we can create an instance of the express constructor like: 
	var app = express();

Then to create a static server we can use a middleware method called 'static' like this:
	app.use(express.static("./public"));

"./public" is the location of the files that we want to host. Then we need the express server to listen to a port like this:
	app.listen(3000);

Then just to make sure that we can use this app in other apps, we need to export it:
	module.exports = app;

To log the requests from the client, we use a middleware and invoke a function. This function has three parameters: request, response and the next command. To log the requests we can use:
	app.use(function(req,res,next){
		console.log(`${req.method} request for '${req.url}'`);
		next();
	});

In the server, if we get 'http' 'get' requests we will send out the reply of that get request:
	app.get("/dictionary-api", function(req,res){
		res.json(skierTerms);
	});
If the api and app are in different domain name, they will not work. To make them work, we use another module, called CORS. This is a piece of middle ware to solve the problem for us. To add the cors module:
	var cors = require("cors");

CORS is a function, which will return some middleware. To use the cors in our app, we write this: 
	app.use(cors());

Till this far we have been catering the "GET" http request through our files. However, there can be other types of requests sent from the clien to the server. The other methods that HTTP can cater are:
	1. GET: Used to retrieve information from server
	2. HEAD: Similar to GET but transfers status and header section only
	3. POST: Used to send data to the server
	4. PUT: Replaces all current representations with uploaded content
	5. DELETE: Used to delete data from server
	6. CONNECT: Creates a tunnel to server
	7. OPTIONS: Describes communication options
	8. TRACE: Performs a message loop-back test along the path to the target resource.

Apart from GET, another very important HTTP method is the POST. Under this method, the client sends some information, usually through HTML forms or file upload, to the server. This information then needs to be used/catered. However, the information that is passed to the server from the client is not directly usable because it will be URL encoded and needs to be parsed before using it. To help us in parsing the data received, we can use another nodejs module, called 'body-parser'. We require this module like following:
	var bodyParser = require("body-parser");

There are two commands that we can use to parse data based on the type of data that received. The first command will convert JSON data to usable format and the second command will convert url encoded data to usable format. The urlencoded() method takes a parameter that is "extended: false", which will be true only if we need to parse nested POST data. The data sent to us can be in either of two format: 
	1. JSON: app.use(bodyParser.json());
	2. URLEncoded: app.use(bodyParser.urlencoded({extended: false}));

In addition to parsing the data, we also need to define additional routes for POST, similar to the one we did for GET method.
	app.post("/dictionary-api", function(req.res){
		//pushes the received req to the array
		skierTerms.push(req.body);
		//then response with the updated skierTerms
		res.json(skierTerms);
	});

To add a DELETE route, we would also need the item name that we want to delete from the array/JSON. To identify that we use ":term" in the route paramenter before the callback function, which will as before will have request and response as its parameters. Inside the callback function we use the filter() method, which takes another callback function (predicate function, which returns boolean). This callback will be invoked for every item found in the arrray. Inside this predicate function, we will check each item in the array with the request received by the server from the client. And then after filtering the item and creating a new json from it, we will responde to the client with the new skierTerms, like this:

	app.delete("/dictionary-api/:term", function(req,res){
		skierTerms = skierTerms.filter(function(definition){
			return definition.term.toLowerCase() !== req.params.term.toLowerCase();
		});
		res.json(skierTerms);
	});

Websockets
----------
Websockets is an advanced technology that helps client and server communicate with each other in real time by keeping a connection open to transfer data. Before introducing the websockets, there were no way to push information from the server to the client. The client had to check continuously make requests to the server to see if there is any change in the state of the server, this method is called 'Polling'. Another method is "long polling", where the client send requests and if there is no change the server let it timeout; however, if there is any change it replies with the changed data. That is to say, 'long polling' is efficient 'polling'. However, with websockets a continuous connection is maintained between the server and the client. So, anytime any of the data is updated in the server, all the other clients get updated data as well. For example, this can be useful in case of chatting apps, where the chat log gets updated in real time for all the users. 

We can use the websocket module by requiring the "ws" module, like this:
	var WebSocketServer = require("ws");

However, this only gives access to the module itself. What we may want to do is to have access to the Server() constructor that lies inside the module. So, we may modify our 'require' statement little bit, like this:
	var WebSocketServer = require("ws").Server;

Then we need to create an instance of the server with 'new' keyword. We also need to pass a port number to the constructor. For example:
	var wss = new WebSocketServer({port: 3000});

We can add an event listener on "connection" event and write a callback on that. This call back will be fired everytime a client connects to the server. So, whatever we write within the callback function will be executed for all the individual connections made to the server.
	wss.on("connection", function(ws){
	  ws.send("Welcome to cyber chat");
	});

However to work with websockets, we also need to configure our client, which we can do through the javascript file that run on the browser. In the javascript file, first we need to create an instance of WebSocket, like:
	var ws = new WebSocket("ws://localhost:3000");

We can run a function when the websocket opens connection. Like:
	ws.onopen = function(){
		document.querySelector("h1").innerHTML = "Connected";
	}

We can also run a function when the websocket connection is closed:
	ws.onclose = function(){
		document.querySelector("h1").innerHTML = "Disconnected";
	}
We can also run a function we receive a message:
	ws.onmessage = function(payload){
		var p = document.createElement("p");
		p.innerText = payload.data;
		document.querySelector("div_message").appendChild(p);
	}

When an user enters an input, we can capture the input and in a function and send it to the websocket. To do this, we need to first listen to an "onsubmit" event, to which we need to assign a function call, which in turn will send the message back to the server. For example:
	document.forms[0].onsubmit = function(){
		var input = document.getElementById("message");
		ws.send(input.value);
		input.value = "";
	}
On the server side, we also need to an event listener for "message" event, which will fire a callback function with "message" as parameter. This event listener and callback should be inside the original "connection" event listener that we created previously. Inside the message event listener, we check whether the message equals "exit"; if it does, then we close the websocket connection using "ws.close()". However, if the message doesn't equal 'exit', then we can access the list of all the client connected to the websocket using "wss.clients", which is an array of clients. So, on this array we can run loops and send the message to each of the clients with forEach and a callback function. The complete code may look like this (including the original "connection" event listener:
	wss.on("connection", function(ws) {
		ws.on("message", function(message){
			if(message === "exit"){
				ws.close();
			} else{
				wss.clients.forEach(function(client){
					client.send(message);
				});
			}
		});
		ws.send("Welcome to cyber chat");
	});

A problem with websocket is that some of the old browsers don't support it. To mitigate this problem, we can use a module 'socket.io', which uses websocket by default but if the browser doesn't support websocket then it uses long polling. To create a socket.io instance, we would need the express module and the http module along with the socket.io module. However, the socket.io module is actually a function; so, we need to pass it a the name of the server that it need to listen to. So, we need to create the server first with http and express modules and then we are going to pass the socket.io the server we just created. We can do these like:
	var express = require("express");
	var http = require("http");
	var app = express();
	var server = http.createServer(app).listen(3000);
	var io = require("socket.io")(server);

Then we can creat a static server with express(as we have done before):
	app.use(express.static("./public"));
Then like before, we would listen to new connections-event and within the callback function with connection-event we need to "emit" a new type of event, in this case, called "message". Along with the event, we are also emitting a message. Also, the socket paramenter need to listen to another event "chat" and invoke a callback function with "message" being the parameter. Inside this callback, we are going to broadcast this message to all the clients. For example:
	io.on("connection", function(socket){
		socket.on("chat",function(message){
			socket.broadcast.emit("message",message);
		});
		socket.emit("message", "Welcome to Cyber Chat!");
	});

On our client-side, we need to add a client file. This file need to be linked with the html. We can download this file from socket.io or "npm install socket.io client".

On our client-side, we also need to configure our original javascript file. In the main js file, we add a new variable for socket and listen to the server like this:
	var socket = io("http://localhost:3000");

Then we can listen to "connect" event and invoke a callback function. 
	socket.on("connect", function() {
		setTitle("Connected to Cyber Chat");
	});
We can also listen to "disconnect" event and invoke another callback function. 
	socket.on("disconnect", function() {
		setTitle("Disconnected");
	});
Another event that we can listen to is the "message" event, also connected to a callback function. 
	socket.on("message", function(message) {
		printMessage(message);
	});

Finally, we need to listen to a "submit" event, which should include an emit method to emit a "chat" event and pass the input.value. For example:
	document.forms[0].onsubmit = function () {
	    var input = document.getElementById("message");
	    printMessage(input.value);
	    socket.emit("chat", input.value);
	    input.value = '';
	};

Useful NPM Packages
-------------------
node-dev: Automatically restarts the app when saved
jshint: Checks JS code for any issues and problems
	jshint, by default, considers ES6 codes as errors. To avoid this we need to include a comment in the JS file:
		/* jshint esnext: true */
httpster: Create simple static http server
	The command for this is:
		httpster -p 3000 -d ./public/
express: Most popular node framework for dynamic server
cors: (Cross Origin Resource Sharing) Open our API to share with other domain
body-parser: parses the request received on POST method
socket.io: used to make websockets
mocha
jasmine
jaster
qunit


Try and Catch
-------------
	try{

	} catch(){

	}

References:
-----------
Nodejs Documentation: https://nodejs.org/api/
HTTP Methods: https://www.tutorialspoint.com/http/http_methods.htm
Node Package Manager (NPM): https://www.npmjs.com/
Javascript Essential Training - Simon Allerdice
Up and Running with ECMAScript 6 - Eve Porcello
Up and Running with Git and GitHub - Ray Vilalobos
